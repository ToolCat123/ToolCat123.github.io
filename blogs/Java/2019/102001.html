<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java面试题1 | Sail</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="blog">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <link rel="preload" href="/assets/css/0.styles.ba62975d.css" as="style"><link rel="preload" href="/assets/js/app.df9b6469.js" as="script"><link rel="preload" href="/assets/js/3.cc36008b.js" as="script"><link rel="preload" href="/assets/js/1.fecf3d02.js" as="script"><link rel="preload" href="/assets/js/17.cc47030b.js" as="script"><link rel="prefetch" href="/assets/js/10.5a8e332a.js"><link rel="prefetch" href="/assets/js/11.029bf4a4.js"><link rel="prefetch" href="/assets/js/12.ad3321e2.js"><link rel="prefetch" href="/assets/js/13.deb36412.js"><link rel="prefetch" href="/assets/js/14.396832a1.js"><link rel="prefetch" href="/assets/js/15.10848c12.js"><link rel="prefetch" href="/assets/js/16.aed06a10.js"><link rel="prefetch" href="/assets/js/18.721bfa07.js"><link rel="prefetch" href="/assets/js/19.c74b3f8b.js"><link rel="prefetch" href="/assets/js/20.7ee83dc0.js"><link rel="prefetch" href="/assets/js/21.d3c71fed.js"><link rel="prefetch" href="/assets/js/22.4b39c759.js"><link rel="prefetch" href="/assets/js/23.df954f27.js"><link rel="prefetch" href="/assets/js/24.080ce141.js"><link rel="prefetch" href="/assets/js/25.f1161116.js"><link rel="prefetch" href="/assets/js/26.96ba3054.js"><link rel="prefetch" href="/assets/js/27.6965a6b0.js"><link rel="prefetch" href="/assets/js/28.dc2e0a08.js"><link rel="prefetch" href="/assets/js/29.ee188e6a.js"><link rel="prefetch" href="/assets/js/30.c81beb8a.js"><link rel="prefetch" href="/assets/js/4.67d4bede.js"><link rel="prefetch" href="/assets/js/5.07e8c5f8.js"><link rel="prefetch" href="/assets/js/6.35eedbe2.js"><link rel="prefetch" href="/assets/js/7.fc9125aa.js"><link rel="prefetch" href="/assets/js/8.a931b049.js"><link rel="prefetch" href="/assets/js/9.9747fe06.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ba62975d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-2d5f533b><div data-v-2d5f533b><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-2d5f533b data-v-2d5f533b><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-2d5f533b data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Sail</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Sail</span>
            
          <span data-v-64685f0e>2019 - </span>
          2020
        </a></span></div></div> <div class="hide" data-v-2d5f533b><header class="navbar" data-v-2d5f533b><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Sail</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/GO/" class="nav-link"><i class="iconfont undefined"></i>
  GO
</a></li><li class="dropdown-item"><!----> <a href="/categories/JS/" class="nav-link"><i class="iconfont undefined"></i>
  JS
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/Linux/" class="nav-link"><i class="iconfont undefined"></i>
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/categories/Python/" class="nav-link"><i class="iconfont undefined"></i>
  Python
</a></li><li class="dropdown-item"><!----> <a href="/categories/SpringBoot/" class="nav-link"><i class="iconfont undefined"></i>
  SpringBoot
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/theme-reco/" class="nav-link"><i class="iconfont undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联络
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/ToolCat123" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-2d5f533b></div> <aside class="sidebar" data-v-2d5f533b><div class="personal-info-wrapper" data-v-ca798c94 data-v-2d5f533b><img src="/avatar.png" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    Sail
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>15</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>12</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/GO/" class="nav-link"><i class="iconfont undefined"></i>
  GO
</a></li><li class="dropdown-item"><!----> <a href="/categories/JS/" class="nav-link"><i class="iconfont undefined"></i>
  JS
</a></li><li class="dropdown-item"><!----> <a href="/categories/Java/" class="nav-link"><i class="iconfont undefined"></i>
  Java
</a></li><li class="dropdown-item"><!----> <a href="/categories/Linux/" class="nav-link"><i class="iconfont undefined"></i>
  Linux
</a></li><li class="dropdown-item"><!----> <a href="/categories/Python/" class="nav-link"><i class="iconfont undefined"></i>
  Python
</a></li><li class="dropdown-item"><!----> <a href="/categories/SpringBoot/" class="nav-link"><i class="iconfont undefined"></i>
  SpringBoot
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间线
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      文档
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/docs/theme-reco/" class="nav-link"><i class="iconfont undefined"></i>
  vuepress-reco
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-message"></i>
      联络
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/ToolCat123" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="iconfont reco-github"></i>
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-2d5f533b><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>Java面试题1</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>Sail</span>
            
          <span data-v-64685f0e>2019 - </span>
          2020
        </a></span></div></div> <div data-v-2d5f533b><main class="page"><div class="page-title" style="display:none;"><h1 class="title">Java面试题1</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>Sail</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2019-10-20</span></i> <!----> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>Java</span><span class="tag-item" data-v-3b7f5bdf>面试</span><span class="tag-item" data-v-3b7f5bdf>Java基础</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><h1 id="java-基础-java面试题1"><a href="#java-基础-java面试题1" class="header-anchor">#</a> Java 基础 Java面试题1</h1> <h2 id="_1-jdk-和-jre-有什么区别"><a href="#_1-jdk-和-jre-有什么区别" class="header-anchor">#</a> 1.JDK 和 JRE 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>JRE:Java Runtime Environment
 JDK：Java Development Kit
 JRE顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用[java语言](https://www.baidu.com/s?wd=java语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的.JDK顾名思义是java开发工具包，是程序员使用[java语言](https://www.baidu.com/s?wd=java语言&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)编写java程序所需的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_2-和-equals-的区别是什么"><a href="#_2-和-equals-的区别是什么" class="header-anchor">#</a> 2.== 和 equals 的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> ==是一个比较运算符，基本数据类型比较的是值，引用数据类型比较的是地址值。

（比较地址值即是指是否为同一个对象的引用）

equals()是一个方法，只能比较引用数据类型。重写前比较的是地址值，重写后比一般是比较对象的属性。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_3-两个对象的-hashcode-相同-则-equals-也一定为-true-对吗"><a href="#_3-两个对象的-hashcode-相同-则-equals-也一定为-true-对吗" class="header-anchor">#</a> 3.两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 不对,如果是同一个类的不同对象，当两者拥有相同hashcode的时候，但可能是不同对象，equals成立的时候则hashcode一定为真。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_4-final-在-java-中有什么作用"><a href="#_4-final-在-java-中有什么作用" class="header-anchor">#</a> 4.final 在 Java 中有什么作用？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>a) final可以修饰类，这样的类不能被继承。

b) final可以修饰方法，这样的方法不能被重写。 

c) final可以修饰变量，这样的变量的值不能被修改，是常量。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_5-java-中的-math-round-11-5-等于多少"><a href="#_5-java-中的-math-round-11-5-等于多少" class="header-anchor">#</a> 5.Java 中的 Math.round(-11.5) 等于多少？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> Math.round(-11.5)等於-11
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_6-string-属于基础的数据类型吗"><a href="#_6-string-属于基础的数据类型吗" class="header-anchor">#</a> 6.String 属于基础的数据类型吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>String不是基本的数据类型，是final修饰的java类，java中的基本类型一共有8个，它们分别为：

1 字符类型：byte，char

2 基本整型：short，int，long

3 浮点型：float，double

4 布尔类型：boolean
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_7-java-中操作字符串都有哪些类-它们之间有什么区别"><a href="#_7-java-中操作字符串都有哪些类-它们之间有什么区别" class="header-anchor">#</a> 7.Java 中操作字符串都有哪些类？它们之间有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> charcharAt(int index) 返回指定索引处的 char 值。

 intcodePointAt(int index) 返回指定索引处的字符（Unicode 代码点）。 intcodePointBefore(int index) 返回指定索引之前的字符（Unicode 代码点）。 intcodePointCount(int beginIndex, int endIndex) 返回此 String 的指定文本范围中的 Unicode 代码点数。 intcompareTo(String anotherString)按字典顺序比较两个字符串。 intcompareToIgnoreCase(String str)不考虑大小写，按字典顺序比较两个字符串。 Stringconcat(String str)将指定字符串联到此字符串的结尾。 

booleancontains(CharSequence s)当且仅当此字符串包含 char 值的指定序列时，才返回 true。 booleancontentEquals(CharSequence cs) 当且仅当此 String 表示与指定序列相同的 char 值时，才返回 true。 booleancontentEquals(StringBuffer sb)
 当且仅当此 String 表示与指定的 StringBuffer 相同的字符序列时，才返回 true。static返回一个新字符串，它是此字符串的一个子字符串。 char[]toCharArray()
 将此字符串转换为一个新的字符数组。 StringtoLowerCase()
 使用默
 返回 Object 参数的字符串表示形式。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_8-string-str-aaa-与-string-str-new-string-aaa-一样吗"><a href="#_8-string-str-aaa-与-string-str-new-string-aaa-一样吗" class="header-anchor">#</a> 8.String str=&quot;aaa&quot;与 String str=new String(“aaa”)一样吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>不一样; &quot;aaa &quot; 是一个[字符串常量](https://www.baidu.com/s?wd=字符串常量&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)，它应该放在静态存储区，和 static， final变量放在一块而new String( &quot;aaa &quot;) 创建了一个和字符串 &quot;aaa &quot;内容一样的字符串，不过这个字符创放在堆上的。String str=new String( &quot;aaa &quot;); 在这条语句中产生了两个字符串,第一个字符串是[字符串常量](https://www.baidu.com/s?wd=字符串常量&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)&quot;aaa &quot;,第二个字符串是new String语句产生的字符串，它的内容和 &quot;aaa &quot;一样。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_9-如何将字符串反转"><a href="#_9-如何将字符串反转" class="header-anchor">#</a> 9.如何将字符串反转？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 通过StringBuilder的reverse()的方法，
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_10-string-类的常用方法都有那些"><a href="#_10-string-类的常用方法都有那些" class="header-anchor">#</a> 10.String 类的常用方法都有那些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1、求字符串长度length();2. 求字符串某一位置字符charAt(int index);3. 提取子串ubstring(int beginIndex),4: 字符串比较compareTo;5. 字符串连接concat(String str)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_11-抽象类必须要有抽象方法吗"><a href="#_11-抽象类必须要有抽象方法吗" class="header-anchor">#</a> 11.抽象类必须要有抽象方法吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 抽象类中可以没有抽象方法，但是抽象方法一定在抽象类中。因为抽象方法和抽象类一样，不能被实例化。区别？
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_12-普通类和抽象类有哪些区别"><a href="#_12-普通类和抽象类有哪些区别" class="header-anchor">#</a> 12.普通类和抽象类有哪些区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 抽象类：
 1、抽象类中可以有普通方法，如果想让方法子类必须实现，就弄成[抽象方法](https://www.baidu.com/s?wd=抽象方法&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)。
 2、如果抽象类中有[抽象方法](https://www.baidu.com/s?wd=抽象方法&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)，那么这个类必须定义为抽象类。
 3、抽象类不能被new。
 普通类：
 1、普通类中不能有[抽象方法](https://www.baidu.com/s?wd=抽象方法&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)。
 2、如果一个普通类实现了一个抽象接口或者抽象类，那么意味着必须重写抽象方法。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_13-抽象类能使用-final-修饰吗"><a href="#_13-抽象类能使用-final-修饰吗" class="header-anchor">#</a> 13.抽象类能使用 final 修饰吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>不能
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_14-接口和抽象类有什么区别"><a href="#_14-接口和抽象类有什么区别" class="header-anchor">#</a> 14.接口和抽象类有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。

2、抽象类要被子类继承，接口要被类实现。

3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现

4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。

5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。

6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果

7、抽象类里可以没有抽象方法

8、如果一个类里有抽象方法，那么这个类只能是抽象类

9、抽象方法要被实现，所以不能是静态的，也不能是私有的。

10、接口可继承接口，并可多继承接口，但类只能单根继承。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_15-java-中-io-流分为几种"><a href="#_15-java-中-io-流分为几种" class="header-anchor">#</a> 15.Java 中 IO 流分为几种？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>按流向分（站在程序角度考虑）

输入流(input)

输出流(output)

按类型分:

字节流(InputStream/OutputStream)

任何文件都可以通过字节流进行传输。

字符流(Reader/Writer)

非纯文本文件，不能用字符流，会导致文件格式破坏，不能正常执行。

节点流(低级流:直接跟输入输出源对接)

FileInputStream/FileOutputStream/FileReader/FileWriter/PrintStream/PrintWriter.

处理流(高级流:建立在低级流的基础上)

转换流：InputStreamReader/OutputStreamWriter，字节流转字符流/字符流转字节流

缓冲流：BufferedInputStream/BufferedOutputStream  BufferedReader/BufferedReader可对节点流经行包装，使读写更快
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h2 id="_17-file的常用方法都有哪些"><a href="#_17-file的常用方法都有哪些" class="header-anchor">#</a> 17.File的常用方法都有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> createNewFile()在指定位置创建一个空文件，成功就返回true，如果已存在就不创建，然后返回false。
 mkdir()  在指定位置创建一个单级文件夹。
 mkdirs()  在指定位置创建一个多级文件夹。
 renameTo(File dest)如果目标文件与源文件是在同一个路径下，那么renameTo的作用是重命名， 如果目标文件与源文件不是在同一个路径下，那么renameTo的作用就是剪切，而且还不能操作文件夹。 

删除：
 delete()  删除文件或者一个空文件夹，不能删除非空文件夹，马上删除文件，返回一个布尔值。
 deleteOnExit()jvm退出时删除文件或者文件夹，用于删除临时文件，无返回值。
 判断：
 exists()  文件或文件夹是否存在。
 isFile()  是否是一个文件，如果不存在，则始终为false。
 isDirectory()  是否是一个目录，如果不存在，则始终为false。
 isHidden()  是否是一个隐藏的文件或是否是隐藏的目录。
 isAbsolute()  测试此抽象路径名是否为绝对路径名。
 获取：
 getName()  获取文件或文件夹的名称，不包含上级路径。
 getAbsolutePath()获取文件的绝对路径，与文件是否存在没关系
 length()  获取文件的大小（字节数），如果文件不存在则返回0L，如果是文件夹也返回0L。
 getParent()  返回此抽象路径名父目录的路径名字符串；如果此路径名没有指定父目录，则返回null。
 lastModified()获取最后一次被修改的时间。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="容器"><a href="#容器" class="header-anchor">#</a> 容器</h2> <h2 id="_18-java-容器都有哪些"><a href="#_18-java-容器都有哪些" class="header-anchor">#</a> 18.Java 容器都有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>数组,String,java.util下的集合容器

数组长度限制为 Integer.Integer.MAX_VALUE;

String的长度限制: 底层是char 数组 长度 Integer.MAX_VALUE 线程安全的

![这里写图片描述](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)

List:存放有序,列表存储,元素可重复

Set:无序,元素不可重复

Map:无序,元素可重复
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_19-collection-和-collections-有什么区别"><a href="#_19-collection-和-collections-有什么区别" class="header-anchor">#</a> 19.Collection 和 Collections 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。

 Collection  
 ├List  
 │├LinkedList  
 │├ArrayList  
 │└Vector  
 │　└Stack  
 └Set

2、Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_20-list、set、map-之间的区别是什么"><a href="#_20-list、set、map-之间的区别是什么" class="header-anchor">#</a> 20.List、Set、Map 之间的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> Java中的集合包括三大类，它们是Set、List和Map，它们都处于[java.util](https://www.baidu.com/s?wd=java.util&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)包中，Set、List和Map都是接口，它们有各自的实现类。Set的实现类主要有HashSet和TreeSet，List的实现类主要有ArrayList，Map的实现类主要有HashMap和TreeMap。
 　Set中的对象不按特定方式排序，并且没有重复对象。但它的有些实现类能对集合中的对象按特定方式排序，例如TreeSet类，它可以按照默认排序，也可以通过实现[java.util](https://www.baidu.com/s?wd=java.util&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao).Comparator&lt;Type&gt;接口来自定义排序方式。
 　List中的对象按照索引位置排序，可以有重复对象，允许按照对象在集合中的索引位置检索对象，如通过list.get(i)方式来获得List集合中的元素。
 　Map中的每一个元素包含一个键对象和值对象，它们成对出现。键对象不能重复，值对象可以重复。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_21-hashmap-和-hashtable-有什么区别"><a href="#_21-hashmap-和-hashtable-有什么区别" class="header-anchor">#</a> 21.HashMap 和 Hashtable 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。

HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。

另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。

由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。

HashMap不能保证随着时间的推移Map中的元素次序是不变的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_22-如何决定使用-hashmap-还是-treemap"><a href="#_22-如何决定使用-hashmap-还是-treemap" class="header-anchor">#</a> 22.如何决定使用 HashMap 还是 TreeMap？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> TreeMap的key按自然增加顺序排序,HashMap没有顺序,HashMap速度快.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_23-说一下-hashmap-的实现原理"><a href="#_23-说一下-hashmap-的实现原理" class="header-anchor">#</a> 23.说一下 HashMap 的实现原理？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。

当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。

因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_24-说一下-hashset-的实现原理"><a href="#_24-说一下-hashset-的实现原理" class="header-anchor">#</a> 24.说一下 HashSet 的实现原理？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>①是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。②当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。③HashSet的其他操作都是基于HashMap的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_25-arraylist-和-linkedlist-的区别是什么"><a href="#_25-arraylist-和-linkedlist-的区别是什么" class="header-anchor">#</a> 25.ArrayList 和 LinkedList 的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1. ArrayList的实现是基于数组，LinkedList的实现是基于双向链表。 

 2. 对于随机访问，ArrayList优于LinkedList

 3. 对于插入和删除操作，LinkedList优于ArrayList

 4. LinkedList比ArrayList更占内存，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_26-如何实现数组和-list-之间的转换"><a href="#_26-如何实现数组和-list-之间的转换" class="header-anchor">#</a> 26.如何实现数组和 List 之间的转换？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>数组转list:Arrays.asList(array);list转数组list.Array().
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_27-arraylist-和-vector-的区别是什么"><a href="#_27-arraylist-和-vector-的区别是什么" class="header-anchor">#</a> 27.ArrayList 和 Vector 的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1） Vector的方法都是同步的(Synchronized),是线程安全的(thread-safe)，而ArrayList的方法不是，由于线程的同步必然要影响性能，因此,ArrayList的性能比Vector好。 
 2） 当Vector或ArrayList中的元素超过它的初始大小时,Vector会将它的容量翻倍,而ArrayList只增加50%的大小，这样,ArrayList就有利于节约内存空间
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_28-array-和-arraylist-有何区别"><a href="#_28-array-和-arraylist-有何区别" class="header-anchor">#</a> 28.Array 和 ArrayList 有何区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
 Array大小是固定的，ArrayList的大小是动态变化的。
 ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
 对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_29-在-queue-中-poll-和-remove-有什么区别"><a href="#_29-在-queue-中-poll-和-remove-有什么区别" class="header-anchor">#</a> 29.在 Queue 中 poll()和 remove()有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>remove方法和poll方法都是删除队列的头元素，remove方法在队列为空的情况下将抛异常，而poll方法将返回null
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_30-哪些集合类是线程安全的"><a href="#_30-哪些集合类是线程安全的" class="header-anchor">#</a> 30.哪些集合类是线程安全的？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。

statck：堆栈类，先进后出

hashtable：就比hashmap多了个线程安全

enumeration：枚举，相当于迭代器
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_31-迭代器-iterator-是什么"><a href="#_31-迭代器-iterator-是什么" class="header-anchor">#</a> 31.迭代器 Iterator 是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>为了方便的处理集合中的元素,Java中出现了一个对象,该对象提供了一些方法专门处理集合中的元素.例如删除和获取集合中的元素.该对象就叫做迭代器(Iterator).
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_32-iterator-怎么使用-有什么特点"><a href="#_32-iterator-怎么使用-有什么特点" class="header-anchor">#</a> 32.Iterator 怎么使用？有什么特点？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Iterator遍历集合元素的过程中不允许线程对集合元素进行修改，否则会抛出ConcurrentModificationEception的异常。

Iterator遍历集合元素的过程中可以通过remove方法来移除集合中的元素。

Iterator必须依附某个Collection对象而存在，Iterator本身不具有装载数据对象的功能。

Iterator.remove方法删除的是上一次Iterator.next()方法返回的对象。

强调以下next（）方法，该方法通过游标指向的形式返回Iterator下一个元素。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_33-iterator-和-listiterator-有什么区别"><a href="#_33-iterator-和-listiterator-有什么区别" class="header-anchor">#</a> 33.Iterator 和 ListIterator 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1. ListIterator有add()方法，可以向List中添加对象，而Iterator不能
2. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。
3. ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。
4. 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_34-怎么确保一个集合不能被修改"><a href="#_34-怎么确保一个集合不能被修改" class="header-anchor">#</a> 34.怎么确保一个集合不能被修改？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>static {

  map.put(1, &quot;one&quot;);

  map.put(2, &quot;two&quot;);

  map = Collections.unmodifiableMap(map);

}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h1 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h1> <h2 id="_35-并行和并发有什么区别"><a href="#_35-并行和并发有什么区别" class="header-anchor">#</a> 35.并行和并发有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.并行是在同一时刻执行多个事件，并发是在同一事件段内执行多个事件

2.并行发生在不同的实体上，并发发生在同一个实体上。并发编程可以充分的利用cpu的，达到最高的处理性能;那为什么并发就能充分利用cpu的执行能力

首先执行多个任务如果是串行执行那么cpu一定会存在等待一个任务执行完去执行下一个任务;但是如果是并发开启多个线程去分别执行不同的任务的时候，这个时候便可以充分的利用cpu，多个线程进行切换去抢占cpu，cpu的空闲时间就会减少。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_36-线程和进程的区别"><a href="#_36-线程和进程的区别" class="header-anchor">#</a> 36.线程和进程的区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个程序至少一个进程，一个进程至少一个线程

地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。

资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_37-守护线程是什么"><a href="#_37-守护线程是什么" class="header-anchor">#</a> 37.守护线程是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_38-创建线程有哪几种方式"><a href="#_38-创建线程有哪几种方式" class="header-anchor">#</a> 38.创建线程有哪几种方式？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>一、继承Thread类创建线程类

二、通过Runnable接口创建线程类

三、通过Callable和Future创建线程
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_39-说一下-runnable-和-callable-有什么区别"><a href="#_39-说一下-runnable-和-callable-有什么区别" class="header-anchor">#</a> 39.说一下 runnable 和 callable 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>(1)Callable规定的方法是call()，Runnable规定的方法是run()。其中Runnable可以提交给Thread来包装下，直接启动一个线程来执行，而Callable则一般都是提交给ExecuteService来执行。 
(2)Callable的任务执行后可返回值，而Runnable的任务是不能返回值得 
(3)call方法可以抛出异常，run方法不可以 
(4)运行Callable任务可以拿到一个Future对象，c表示异步计算的结果。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_40-线程有哪些状态"><a href="#_40-线程有哪些状态" class="header-anchor">#</a> 40.线程有哪些状态？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>线程状态有 5 种，新建，就绪，运行，阻塞，死亡
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_41-sleep-和-wait-有什么区别"><a href="#_41-sleep-和-wait-有什么区别" class="header-anchor">#</a> 41.sleep() 和 wait() 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>sleep()方法正在执行的线程主动让出[CPU](https://www.baidu.com/s?wd=CPU&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd)（然后CPU就可以去执行其他任务），在sleep指定时间后CPU再回到该线程继续往下执行(注意：sleep方法只让出了CPU，而并不会释放同步资源锁！！！)；wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。（注意：notify的作用相当于叫醒睡着的人，而并不会给他分配任务，就是说notify只是让之前调用wait的线程有权利重新参与线程的调度）；sleep()方法可以在任何地方使用；wait()方法则只能在同步方法或同步块中使用；sleep()是线程线程类（Thread）的方法，调用会暂停此线程指定的时间，但监控依然保持，不会释放对象锁，到时间自动恢复；wait()是Object的方法，调用会放弃对象锁，进入等待队列，待调用notify()/notifyAll()唤醒指定的线程或者所有线程，才会进入锁池，不再次获得对象锁才会进入运行状态；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_42-notify-和-notifyall-有什么区别"><a href="#_42-notify-和-notifyall-有什么区别" class="header-anchor">#</a> 42.notify()和 notifyAll()有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_43-线程的-run-和-start-有什么区别"><a href="#_43-线程的-run-和-start-有什么区别" class="header-anchor">#</a> 43.线程的 run()和 start()有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>run()相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。

而start()的作用是启动相应的线程。启动一个线程实际是请求Java虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。start()调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_44-创建线程池有哪几种方式"><a href="#_44-创建线程池有哪几种方式" class="header-anchor">#</a> 44.创建线程池有哪几种方式？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>newSingleThreadExecutor 单线程的线程池

newFixedThreadPool 固定大小的线程池。

newCachedThreadPool  可缓存的线程池

newScheduledThreadPool 大小无限的线程池
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_45-线程池都有哪些状态"><a href="#_45-线程池都有哪些状态" class="header-anchor">#</a> 45.线程池都有哪些状态？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>线程池的5种状态：Running、ShutDown、Stop、Tidying、Terminated。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_46-线程池中-submit-和-execute-方法有什么区别"><a href="#_46-线程池中-submit-和-execute-方法有什么区别" class="header-anchor">#</a> 46.线程池中 submit()和 execute()方法有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、接收的参数不一样2、submit有返回值，而execute没有3、submit方便Exception处理
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_47-在-java-程序中怎么保证多线程的运行安全"><a href="#_47-在-java-程序中怎么保证多线程的运行安全" class="header-anchor">#</a> 47.在 Java 程序中怎么保证多线程的运行安全？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；

2.可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；

3.有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_48-多线程锁的升级原理是什么"><a href="#_48-多线程锁的升级原理是什么" class="header-anchor">#</a> 48.多线程锁的升级原理是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>当对象获取锁时，它首先使自己的高速缓存无效，这样就可以保证直接从主内存中装入变量。 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_49-什么是死锁"><a href="#_49-什么是死锁" class="header-anchor">#</a> 49.什么是死锁？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_50-怎么防止死锁"><a href="#_50-怎么防止死锁" class="header-anchor">#</a> 50.怎么防止死锁？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>设置加锁顺序;设置加锁时限;死锁检测
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_51-threadlocal-是什么-有哪些使用场景"><a href="#_51-threadlocal-是什么-有哪些使用场景" class="header-anchor">#</a> 51.ThreadLocal 是什么？有哪些使用场景？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>原来我们常用的局部变量和静态变量，在某种情况下无法满足要求，比如，我要求缓存一个变量，这个时候你肯定会说搞一个静态map存一下就OK了，但是有几个问题：

第一：其他线程擅自修改我的这个静态map怎么办？

第二：静态map之间并发访问怎么办？

当然，也有人说而已使用局部变量，然后通过传递引用来实现在不同的场合使用，但是这样就要依赖具体方法的入参和出参，至少你要增加一个入参来传入这个引用吧？
 这种情况下，ThreadLocal就可以发挥他的威力了，它的本质就是一个内部的静态map，key是当前线程的一个句柄，value是需要保存的值，当然value可以是任何类型的，至少是一个map或者容器把，不然一个线程就只能存一个value了，太不实用。

基于上面这种设计，每个线程其实根本无法获取到其他线程的key，由于是内部静态map，不提供遍历和查询的接口，也确保了其他线程只能根据key获取，所以，每个线程只能取到自己线程的value。

这样，即做到了线程安全，又在线程范围内提供了数据共享的能力
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_52-说一下-synchronized-底层实现原理"><a href="#_52-说一下-synchronized-底层实现原理" class="header-anchor">#</a> 52.说一下 Synchronized 底层实现原理？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

普通同步方法，锁是当前实例对象

静态同步方法，锁是当前类的class对象

同步方法块，锁是括号里面的对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_53-synchronized-和-volatile-的区别是什么"><a href="#_53-synchronized-和-volatile-的区别是什么" class="header-anchor">#</a> 53.Synchronized 和 Volatile 的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的

volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性

volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_54-synchronized-和-lock-有什么区别"><a href="#_54-synchronized-和-lock-有什么区别" class="header-anchor">#</a> 54.Synchronized 和 Lock 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1）Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问；

2）Lock和synchronized有一点非常大的不同，采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_55-synchronized-和-reentrantlock-区别是什么"><a href="#_55-synchronized-和-reentrantlock-区别是什么" class="header-anchor">#</a> 55.Synchronized 和 ReentrantLock 区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>synchronized： 
 在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。 
 
 ReentrantLock: 
 ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。 
 
 Atomic: 
 和上面的类似，不激烈情况下，性能比synchronized略逊，而激烈的时候，也能维持常态。激烈的时候，Atomic的性能会优于ReentrantLock一倍左右。但是其有一个缺点，就是只能同步一个值，一段代码中只能出现一个Atomic的变量，多于一个同步无效。因为他不能在多个Atomic之间同步。 
 所以，我们写同步的时候，优先考虑synchronized，如果有特殊需要，再进一步优化。ReentrantLock和Atomic如果用的不好，不仅不能提高性能，还可能带来灾难。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_56-说一下-atomic-的原理"><a href="#_56-说一下-atomic-的原理" class="header-anchor">#</a> 56.说一下 Atomic 的原理？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>atomic的seter getter内部实现是用了互斥锁来保证seter getter方法在多线程中的安全，但atomic修饰的对象是我们自定义的，可能并没有加锁，在多线程中atomic修饰对象并不能保证线程安全。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h1 id="反射"><a href="#反射" class="header-anchor">#</a> 反射</h1> <h2 id="_57-什么是反射"><a href="#_57-什么是反射" class="header-anchor">#</a> 57.什么是反射？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>AVA中反射是动态获取信息以及动态调用对象方法的一种反射机制。

Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态语言的一个关键性质。

Java反射的功能是在运行时判断任意一个对象所属的类，在运行时构造任意一个类的对象，在运行时判断任意一个类所具有的成员变量和方法，在运行时调用任意一个对象的方法，生成动态代理。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_58-什么是-java-序列化-什么情况下需要序列化"><a href="#_58-什么是-java-序列化-什么情况下需要序列化" class="header-anchor">#</a> 58.什么是 Java 序列化？什么情况下需要序列化？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化,将数据分解成字节流，以便存储在文件中或在网络上传输。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题什么时候使用序列化： 
 　一：对象序列化可以实现分布式对象。主要应用例如：RMI要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。 
 　二：java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的&quot;深复制&quot;，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_59-动态代理是什么-有哪些应用"><a href="#_59-动态代理是什么-有哪些应用" class="header-anchor">#</a> 59.动态代理是什么？有哪些应用？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。

动态代理的应用：Spring的AOP，加事务，加权限，加日志
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_60-怎么实现动态代理"><a href="#_60-怎么实现动态代理" class="header-anchor">#</a> 60.怎么实现动态代理？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 动态代理实现：首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h1 id="对象拷贝"><a href="#对象拷贝" class="header-anchor">#</a> 对象拷贝</h1> <h2 id="_61-为什么要使用克隆"><a href="#_61-为什么要使用克隆" class="header-anchor">#</a> 61.为什么要使用克隆？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 克隆是另一个作用，比如，你要传递给另一个对象的某个方法method的参数中包含A对象，但是，你不知道这个方法是不是对你的A进行了修改，而你又不想他修改，或者说他修改了也不会对你有任何影响，你就可以使用克隆来完成这个任务。这样即使他修改了，也只是对你的克隆对象的修改，而没有对你的那个对象本身进行修改。
 克隆还有一个作用，对于数据bean，如果你有beanA,想快速创建一个类似的beanB，而只是其中的一两个属性不一样，就可以使用克隆来完成了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_62-如何实现对象克隆"><a href="#_62-如何实现对象克隆" class="header-anchor">#</a> 62.如何实现对象克隆？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>有两种方式：
 1). 实现Cloneable接口并重写Object类中的clone()方法；
 2).实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆，
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_63-深拷贝和浅拷贝区别是什么"><a href="#_63-深拷贝和浅拷贝区别是什么" class="header-anchor">#</a> 63.深拷贝和浅拷贝区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）

深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="java-web"><a href="#java-web" class="header-anchor">#</a> Java Web</h1> <h2 id="_64-jsp-和-servlet-有什么区别"><a href="#_64-jsp-和-servlet-有什么区别" class="header-anchor">#</a> 64.JSP 和 Servlet 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.jsp经编译后就变成了Servlet.(JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码,Web容器将JSP的代码编译成JVM能够识别的java类)
2.jsp更擅长表现于页面显示,servlet更擅长于逻辑控制.
3.Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到.
Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_65-jsp-有哪些内置对象-作用分别是什么"><a href="#_65-jsp-有哪些内置对象-作用分别是什么" class="header-anchor">#</a> 65.JSP 有哪些内置对象？作用分别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1、pageContext 表示页容器 –&gt;EL、标签、上传
 2、request 服务器端取得客户端的信息：头信息、Cookie、请求参数、MVC设计模式
 3、response 服务器端回应给客户端信息：Cookie、重定向
 4、session 表示每一个用户，用于登录验证上
 5、application 表示整个服务器，getRealPath()
 6、config 去的初始化参数，初始化参数在web.xml中配置
 7、exception 表示的是错误页的处理操作
 8、page 如同this一样，表示整个JSP页面
 9、out 输出，但是尽量使用表达式输出
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_66-说一下-jsp-的-4-种作用域"><a href="#_66-说一下-jsp-的-4-种作用域" class="header-anchor">#</a> 66.说一下 JSP 的 4 种作用域？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_67-session-和-cookie-有什么区别"><a href="#_67-session-和-cookie-有什么区别" class="header-anchor">#</a> 67.Session 和 Cookie 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Cookie是把用户的数据写给用户的浏览器。

Session技术把用户的数据写到用户独占的session中。

Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_68-说一下-session-的工作原理"><a href="#_68-说一下-session-的工作原理" class="header-anchor">#</a> 68.说一下 Session 的工作原理？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>session是依赖Cookie实现的。session是服务器端对象

 当用户第一次使用session时（表示第一次请求服务器），服务器会创建session，并创建一个Cookie，在Cookie中保存了session的id，发送给客户端。这样客户端就有了自己session的id了。但这个Cookie只在浏览器内存中存在，也就是说，在关闭浏览器窗口后，Cookie就会丢失，也就丢失了sessionId。

 当用户第二次访问服务器时，会在请求中把保存了sessionId的Cookie发送给服务器，服务器通过sessionId查找session对象，然后给使用。也就是说，只要浏览器容器不关闭，无论访问服务器多少次，使用的都是同一个session对象。这样也就可以让多个请求共享同一个session了。

 当用户关闭了浏览器窗口后，再打开浏览器访问服务器，这时请求中没有了sessionId，那么服务器会创建一个session，再把sessionId通过Cookie保存到浏览器中，也是一个新的会话开始了。原来的session会因为长时间无法访问而失效。

 

 当用户打开某个服务器页面长时间没动作时，这样session会超时失效，当用户再有活动时，服务器通过用户提供的sessionId已经找不到session对象了，那么服务器还是会创建一个新的session对象，再把新的sessionId保存到客户端。这也是一个新的会话开始了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_69-如果客户端禁止-cookie-能实现-session-还能用吗"><a href="#_69-如果客户端禁止-cookie-能实现-session-还能用吗" class="header-anchor">#</a> 69.如果客户端禁止 Cookie 能实现 Session 还能用吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 但为什么禁用Cookie就不能得到Session呢？因为Session是用Session ID来确定当前对话所对应的服务器Session，而Session ID是通过Cookie来传递的，禁用Cookie相当于失去了Session ID，也就得不到Session了。

假定用户关闭Cookie的情况下使用Session，其实现途径有以下几种：

  1》 设置php.ini配置文件中的“session.use_trans_sid = 1”，或者编译时打开打开了“--enable-trans-sid”选项，让PHP自动跨页传递Session ID。

  2》 手动通过URL传值、隐藏表单传递Session ID。

  3》 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_70-spring-mvc-和-struts-的区别是什么"><a href="#_70-spring-mvc-和-struts-的区别是什么" class="header-anchor">#</a> 70.Spring MVC 和 Struts 的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 一、拦截机制的不同

　　Struts2是类级别的拦截，每次请求就会创建一个Action，和Spring整合时Struts2的ActionBean注入作用域是原型模式prototype，然后通过setter，getter吧request数据注入到属性。Struts2中，一个Action对应一个request，response上下文，在接收参数时，可以通过属性接收，这说明属性参数是让多个方法共享的。Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了，只能设计为多例。

　　SpringMVC是方法级别的拦截，一个方法对应一个Request上下文，所以方法直接基本上是独立的，独享request，response数据。而每个方法同时又何一个url对应，参数的传递是直接注入到方法中的，是方法所独有的。处理结果通过ModeMap返回给框架。在Spring整合时，SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，有应为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。

　　Struts2有自己的拦截Interceptor机制，SpringMVC这是用的是独立的Aop方式，这样导致Struts2的配置文件量还是比SpringMVC大。

二、底层框架的不同

　　Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现，SpringMVC（DispatcherServlet）则采用Servlet实现。Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。

三、性能方面

　　Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，SpringMVC实现了零配置，由于SpringMVC基于方法的拦截，有加载一次单例模式bean注入。所以，SpringMVC开发效率和性能高于Struts2。

四、配置方面

　　spring MVC和Spring是无缝的。从这个项目的管理和安全上也比Struts2高。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_71-如何避免-sql-注入"><a href="#_71-如何避免-sql-注入" class="header-anchor">#</a> 71.如何避免 SQL 注入？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.（简单又有效的方法）PreparedStatement

2.使用正则表达式过滤传入的参数

3.字符串过滤

4.jsp中调用该函数检查是否包函非法字符

5.JSP页面判断代码：
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_72-什么是-xss-攻击-如何避免"><a href="#_72-什么是-xss-攻击-如何避免" class="header-anchor">#</a> 72.什么是 XSS 攻击，如何避免？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>XSS（Cross Site Scripting），即跨站脚本攻击，是一种常见于web应用程序中的计算机安全漏洞.XSS通过在用户端注入恶意的可运行脚本，若服务器端对用户输入不进行处理，直接将用户输入输出到浏览器，然后浏览器将会执行用户注入的脚本

防御：（好多种情况，这里只说最简单的）

其恶意脚本都是来自用户的输入。因此，可以使用过滤用户输入的方法对恶意脚本进行过滤。

1、获取用户输入，不用.innerHTML，用innerText。

2、对用户输入进行过滤，如 HTMLEncode 函数实现应该至少进行 &amp; &lt; &gt; &quot; ' / 等符号转义成 &amp;amp &amp;lt &amp;gt &amp;quot &amp;#x27 &amp;#x2F；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_73-什么是-csrf-攻击-如何避免"><a href="#_73-什么是-csrf-攻击-如何避免" class="header-anchor">#</a> 73.什么是 CSRF 攻击，如何避免？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>只需构造正确的Get链接，让浏览器发送Get请求。由于用户已经登录，因此它将携带正确的cookie并直接访问链接以实现相关功能。

在了解了原理之后，如何破解黑客的攻击？解决方案是向表单添加字段标记。黑客无法猜出已经改变的令牌，所以即使你添加一个UUID令牌，将它保存到服务器会话，黑客也不可能猜出随机令牌，就无法构造出能实现功能的链接了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="异常"><a href="#异常" class="header-anchor">#</a> 异常</h1> <h2 id="_74-throw-和-throws-的区别"><a href="#_74-throw-和-throws-的区别" class="header-anchor">#</a> 74.throw 和 throws 的区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_75-final、finally、finalize-有什么区别"><a href="#_75-final、finally、finalize-有什么区别" class="header-anchor">#</a> 75.final、finally、finalize 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。

finally 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。

finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_76-try-catch-finally-中哪个部分可以省略"><a href="#_76-try-catch-finally-中哪个部分可以省略" class="header-anchor">#</a> 76.try-catch-finally 中哪个部分可以省略？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>try和catch可以连用，try-catch- finally可以连用，这是众所周知的，但是try、catch、finally这三个关键字却不能单独使用，如果在程序中只想try而不去catch也是可以的，但是try的后面必须跟有finally。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_77-try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗"><a href="#_77-try-catch-finally-中-如果-catch-中-return-了-finally-还会执行吗" class="header-anchor">#</a> 77.try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>会执行，在return 前执行;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_78-常见的异常类有哪些"><a href="#_78-常见的异常类有哪些" class="header-anchor">#</a> 78.常见的异常类有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Exception 类扩展出数个子类，其中 IOException、RunntimeException 是较常用的两种。

![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h1 id="网络"><a href="#网络" class="header-anchor">#</a> 网络</h1> <h2 id="_79-http-响应码-301-和-302-代表的是什么-有什么区别"><a href="#_79-http-响应码-301-和-302-代表的是什么-有什么区别" class="header-anchor">#</a> 79.HTTP 响应码 301 和 302 代表的是什么？有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 301，302 都是HTTP状态的编码，都代表着某个URL发生了转移，不同之处在于： 
 301 redirect: 301 代表永久性转移(Permanently Moved)。
 302 redirect: 302 代表暂时性转移(Temporarily Moved )。

302转向可能会有URL规范化及网址劫持的问题

当网页A用301重定向转到网页B时，搜索引擎可以肯定网页A永久的改变位置，或者说实际上不存在了，搜索引擎就会把网页B当作唯一有效目标。
 301的好处是:
 第一， 没有网址规范化问题。
 第二， 也很重要的，网页A的PR网页级别会传到网页B。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="_80-forward-和-redirect-的区别"><a href="#_80-forward-和-redirect-的区别" class="header-anchor">#</a> 80.Forward 和 Redirect 的区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1.从地址栏显示来说
 forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
 redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.
 2.从数据共享来说
 forward:转发页面和转发到的页面可以共享request里面的数据.
 redirect:不能共享数据.
 3.从运用地方来说
 forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
 redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.
 4.从效率来说
 forward:高.
 redirect:低.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_81-简述-tcp-和-udp-的区别"><a href="#_81-简述-tcp-和-udp-的区别" class="header-anchor">#</a> 81.简述 TCP 和 UDP 的区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1。TCP是基于连接的，UDP是基于无连接 
2。对系统资源的要求（TCP较多，UDP少） 
3。UDP程序结构较简单 
4。流模式与数据报模式 
5。TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_82-tcp-为什么要三次握手-两次不行吗-为什么"><a href="#_82-tcp-为什么要三次握手-两次不行吗-为什么" class="header-anchor">#</a> 82.TCP 为什么要三次握手，两次不行吗？为什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>为什么不采用两次握手？
 如果是两次握手的情景:
 客户端在发送一个连接建立请求之后进入等待状态，等到服务端确认之后就进入established状态。服务端在发送一个确认连接建立请求报文之后(不管客户端是否有回应)也进入established状态。
 这就好比，
 A给B打电话，
 A:你听得到我说话吗？
 B:我听得到啊
 A和B就都以为对方都能听得到自己了。
 但有一种情况是，B的麦是坏的，A根本就听不到B说话，结果A没收到B的回应，但B却以为A能听得到他，B就一直等着A说点什么...这样让B身心俱疲。

三次握手:
 客户端在发送一个连接建立请求报文之后进入等待状态，等到服务端返回确认建立连接的通知;
 服务端发送确认建立连接请求报文，同时向客户端发送连接建立请求报文，进入等待状态。

客户端接受到服务端发送的确认请求报文。进入established状态。客户端接受到来自服务端的连接建立请求报文，发送确认连接建立请求报文。

服务端接受到来自客户端的确认建立连接报文，进入established。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_83-说一下-tcp-粘包是怎么产生的"><a href="#_83-说一下-tcp-粘包是怎么产生的" class="header-anchor">#</a> 83.说一下 TCP 粘包是怎么产生的？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据negal优化[算法](http://lib.csdn.net/base/datastructure)把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_84-osi-的七层模型都有哪些"><a href="#_84-osi-的七层模型都有哪些" class="header-anchor">#</a> 84.OSI 的七层模型都有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_85-get和-post-请求有哪些区别"><a href="#_85-get和-post-请求有哪些区别" class="header-anchor">#</a> 85.Get和 Post 请求有哪些区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> （1）post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中） 
 （2）post发送的数据更大（get有url长度限制） 
 （3）post能发送更多的数据类型（get只能发送ASCII字符） 
 （4）post比get慢 
 （5）post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_86-如何实现跨域"><a href="#_86-如何实现跨域" class="header-anchor">#</a> 86.如何实现跨域？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>方式一：图片ping或script标签跨域

方式二：JSONP跨域

方式三：CORS

方式四：window.name+iframe

方式五：window.postMessage()

方式六：修改document.domain跨子域

方式七：WebSocket

方式八：代理
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_87-说一下-jsonp-实现原理"><a href="#_87-说一下-jsonp-实现原理" class="header-anchor">#</a> 87.说一下 JSONP 实现原理？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 &lt;script&gt;元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h1 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h1> <h2 id="_88-说一下你熟悉的设计模式"><a href="#_88-说一下你熟悉的设计模式" class="header-anchor">#</a> 88.说一下你熟悉的设计模式？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> [工厂方法模式](https://www.baidu.com/s?wd=工厂方法模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Factory Method Pattern）
  抽象工厂模式（Abstract Factory Pattern）
  [建造者模式](https://www.baidu.com/s?wd=建造者模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Builder Pattern）
  原型模式（Prototype Pattern）
  [单例模式](https://www.baidu.com/s?wd=单例模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Singleton Pattern）
 结构型模式用来处理类或者对象的组合，主要包含以下7种设计模式：
  [适配器模式](https://www.baidu.com/s?wd=适配器模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Adapter Pattern）
  [桥接模式](https://www.baidu.com/s?wd=桥接模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Bridge Pattern）
  组合模式（Composite Pattern）
  装饰者模式（Decorator Pattern）
  外观模式（Facade Pattern）
  [享元模式](https://www.baidu.com/s?wd=享元模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Flyweight Pattern）
  [代理模式](https://www.baidu.com/s?wd=代理模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Proxy Pattern）
 行为型模式用来对类或对象怎样交互和怎样分配职责进行描述主要包含以下11种设计模式：
  [责任链模式](https://www.baidu.com/s?wd=责任链模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Chain of Responsibility Pattern）
  [命令模式](https://www.baidu.com/s?wd=命令模式&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)（Command Pattern）
  解释器模式（Interpreter Pattern）
  迭代器模式（Iterator Pattern）
  中介者模式（Mediator Pattern）
  备忘录模式（Memento Pattern）
  观察者模式（Observer Pattern）
  状态模式（State Pattern）
  策略模式（Strategy Pattern）
  模板方法模式（Template Method Pattern）
  访问者模式（Visitor Pattern）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><h2 id="_89-简单工厂和抽象工厂有什么区别"><a href="#_89-简单工厂和抽象工厂有什么区别" class="header-anchor">#</a> 89.简单工厂和抽象工厂有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>优点

简单工厂模式：工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅&quot;消费&quot;产品。简单工厂模式通过这种做法实现了对责任的分割。简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过它，外界可以从直接创建具体产品对象的尴尬局面中摆脱出来。外界与具体类隔离开来，偶合性低。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。         

工厂方法模式：工厂方法模式是为了克服简单工厂模式的缺点（主要是为了满足OCP）而设计出来的。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。工厂方法模式完全满足OCP，即它有非常良好的扩展性。          

抽象工厂模式：抽象工厂模式主要在于应对“新系列”的需求变化。分离了具体的类，抽象工厂模式帮助你控制一个应用创建的对象的类，因为一个工厂封装创建产品对象的责任和过程。它将客户和类的实现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。它使得易于交换产品系列。一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。它有利于产品的一致性。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。抽象工厂模式有助于这样的团队的分工，降低了模块间的耦合性，提高了团队开发效率。           

三．缺点

简单工厂模式：当产品有复杂的多层等级结构时，工厂类只有自己，以不变应万变，就是模式的缺点。因为工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，有可能造成工厂逻辑过于复杂,违背了&quot;开放--封闭&quot;原则(OCP).另外，简单工厂模式通常使用静态工厂方法，这使得无法由子类继承，造成工厂角色无法形成基于继承的等级结构。         

工厂方法模式：不易于维护，假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。         

抽象工厂模式：抽象工厂模式在于难于应付“新对象”的需求变动。难以支持新种类的产品。难以扩展抽象工厂以生产新种类的产品。这是因为抽象工厂几乎确定了可以被创建的产品集合，支持新种类的产品就需要扩展该工厂接口，这将涉及抽象工厂类及其所有子类的改变。          

四．适用范围

简单工厂模式：工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。           

工厂方法模式：当一个类不知道它所必须创建对象的类或一个类希望由子类来指定它所创建的对象时，当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候，可以使用工厂方法。           

抽象工厂模式：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。这个系统有多于一个的产品族，而系统只消费其中某一产品族。同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。         

其实，无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h1 id="spring-spring-mvc"><a href="#spring-spring-mvc" class="header-anchor">#</a> Spring/Spring MVC</h1> <h2 id="_90-为什么要使用-spring"><a href="#_90-为什么要使用-spring" class="header-anchor">#</a> 90.为什么要使用 Spring？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.方便解耦，便于开发（Spring就是一个大工厂，可以将所有对象的创建和依赖关系维护都交给spring管理）

2.spring支持aop编程（spring提供面向切面编程，可以很方便的实现对程序进行权限拦截和运行监控等功能）

3.声明式事务的支持（通过配置就完成对事务的支持，不需要手动编程）

4.方便程序的测试，spring 对junit4支持，可以通过注解方便的测试spring 程序

5.方便集成各种优秀的框架（）

6.降低javaEE API的使用难度（Spring 对javaEE开发中非常难用的一些API 例如JDBC,javaMail,远程调用等，都提供了封装，是这些API应用难度大大降低）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_91-解释一下什么是-aop"><a href="#_91-解释一下什么是-aop" class="header-anchor">#</a> 91.解释一下什么是 AOP？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>AOP即面向切面编程，是OOP编程的有效补充。

使用AOP技术，可以将一些系统性相关的编程工作，独立提取出来，独立实现，然后通过切面切入进系统。

从而避免了在业务逻辑的代码中混入很多的系统相关的逻辑——比如权限管理，事物管理，日志记录等等。

这些系统性的编程工作都可以独立编码实现，然后通过AOP技术切入进系统即可。从而达到了 将不同的关注点分离出来的效果。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_92-解释一下什么是-ioc"><a href="#_92-解释一下什么是-ioc" class="header-anchor">#</a> 92.解释一下什么是 IOC？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_93-spring-有哪些主要模块"><a href="#_93-spring-有哪些主要模块" class="header-anchor">#</a> 93.Spring 有哪些主要模块？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1. Spring AOP 面相切面编程
 2. Spring ORM Hibernate|mybatis|JDO
 3. Spring Core 提供bean工厂 IOC
 4. Spring Dao JDBC支持
 5. Spring Context 提供了关于UI支持,邮件支持等
 6. Spring Web 提供了web的一些工具类的支持
 7. Spring MVC 提供了web mvc , webviews , jsp ,pdf ,export
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_94-spring-常用的注入方式有哪些"><a href="#_94-spring-常用的注入方式有哪些" class="header-anchor">#</a> 94.Spring 常用的注入方式有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>构造方法注入，setter注入，接口注入。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_95-spring-中的-bean-是线程安全的吗"><a href="#_95-spring-中的-bean-是线程安全的吗" class="header-anchor">#</a> 95.Spring 中的 Bean 是线程安全的吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>如果在你不定义成员变量的情况下，spring默认是线程安全的

否则，设置scope=&quot;prototype&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_96-spring-支持几种-bean-的作用域"><a href="#_96-spring-支持几种-bean-的作用域" class="header-anchor">#</a> 96.Spring 支持几种 Bean 的作用域？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例

prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例

request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效

session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效

globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_97-spring-自动装配-bean-有哪些方式"><a href="#_97-spring-自动装配-bean-有哪些方式" class="header-anchor">#</a> 97.Spring 自动装配 Bean 有哪些方式？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.按bean名称装配

2.按bean类型装配
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_98-spring-事务实现方式有哪些"><a href="#_98-spring-事务实现方式有哪些" class="header-anchor">#</a> 98.Spring 事务实现方式有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>实现方式共有两种：编码方式；声明式事务管理方式
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_99-说一下-spring-的事务隔离"><a href="#_99-说一下-spring-的事务隔离" class="header-anchor">#</a> 99.说一下 Spring 的事务隔离？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别. 

未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生

已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生

可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生. 

串行化的 （serializable） :避免以上所有读问题. 

![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_100-说一下-spring-mvc-运行流程"><a href="#_100-说一下-spring-mvc-运行流程" class="header-anchor">#</a> 100.说一下 Spring MVC 运行流程？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>（1）客户端通过url发送请求
（2-3）核心控制器Dispatcher Servlet接收到请求，通过系统或自定义的映射器配置找到对应的handler，并将url映射的控制器controller返回给核心控制器。
（4）通过核心控制器找到系统或默认的适配器
（5-7）由找到的适配器，调用实现对应接口的处理器，并将结果返回给适配器，结果中包含数据模型和视图对象，再由适配器返回给核心控制器
（8-9）核心控制器将获取的数据和视图结合的对象传递给视图解析器，获取解析得到的结果，并由视图解析器响应给核心控制器
（10）核心控制器将结果返回给客户端
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_101-spring-mvc-有哪些组件"><a href="#_101-spring-mvc-有哪些组件" class="header-anchor">#</a> 101.Spring MVC 有哪些组件？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>处理器映射器：用户请求路径到Controller方法的映射

处理器适配器：根据handler(controlelr类）的开发方式（注解开发/其他开发） 方式的不同区寻找不同的处理器适配器

视图解析器：根据handler返回的view地址文件类型（jsp/pdf….）去寻找相应的视图解析器来进行解析
 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_102-requestmapping-的作用是什么"><a href="#_102-requestmapping-的作用是什么" class="header-anchor">#</a> 102.@RequestMapping 的作用是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> @RequestMapping 除了修饰方法, 还可来修饰类 2. 1). 类定义处: 提供初步的请求映射信息。相对于 WEB 应用的根目录
 方法处: 提供进一步的细分映射信息。 相对于类定义处的 URL。若类定义处未标注 @RequestMapping，则方法处标记的 URL
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_103-autowired-的作用是什么"><a href="#_103-autowired-的作用是什么" class="header-anchor">#</a> 103.@Autowired 的作用是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>[@Autowired](https://www.baidu.com/s?wd=%40Autowired&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)进行自动注入时，spring容器中匹配的候选Bean数目必须有且仅有一个。
 当找不到一个匹配的Bean时，spring容器将抛出BeanCreationException异常，并指出必须至少拥有一个匹配的Bean。
 如果spring容器中拥有多个候选Bean，spring容器在启动时也会抛出BeanCreationException
 这个时候就可以借助[@Qualifier](https://www.baidu.com/s?wd=%40Qualifier&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)注释指定注入Bean的名称，这样[@Autowired](https://www.baidu.com/s?wd=%40Autowired&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)遇到多个候选Bean的问题也就解决了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h1 id="spring-boot-spring-cloud"><a href="#spring-boot-spring-cloud" class="header-anchor">#</a> Spring Boot/Spring Cloud</h1> <h2 id="_104-什么是-spring-boot"><a href="#_104-什么是-spring-boot" class="header-anchor">#</a> 104.什么是 Spring Boot？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_105-为什么要用-spring-boot"><a href="#_105-为什么要用-spring-boot" class="header-anchor">#</a> 105.为什么要用 Spring Boot？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_106-spring-boot-核心配置文件是什么"><a href="#_106-spring-boot-核心配置文件是什么" class="header-anchor">#</a> 106.Spring Boot 核心配置文件是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> SpringBoot使用默认的全局的配置文件，application.properties / application.yml,配置文件名固定。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_107-spring-boot-配置文件有哪几种类型-它们有什么区别"><a href="#_107-spring-boot-配置文件有哪几种类型-它们有什么区别" class="header-anchor">#</a> 107.Spring Boot 配置文件有哪几种类型？它们有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、在properties文件中是以”.”进行分割的， 在yml中是用”:”进行分割;

2、yml的数据格式和json的格式很像，都是K-V格式，并且通过”:”进行赋值； 

3、在yml中缩进一定不能使用TAB，否则会报很奇怪的错误；（缩进特么只能用空格！！！！） 

4、每个k的冒号后面一定都要加一个空格；

5、使用spring cloud的maven进行构造的项目，在把properties换成yml后，一定要进行mvn clean insatll
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_108-spring-boot-有哪些方式可以实现热部署"><a href="#_108-spring-boot-有哪些方式可以实现热部署" class="header-anchor">#</a> 108.Spring Boot 有哪些方式可以实现热部署？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>使用 [Spring Loaded](https://github.com/spring-projects/spring-loaded)

使用 spring-boot-devtools
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_109-jpa-和-hibernate-有什么区别"><a href="#_109-jpa-和-hibernate-有什么区别" class="header-anchor">#</a> 109.JPA 和 Hibernate 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Hibernate是JPA规范的一个具体实现

hibernate有JPA没有的特性 

hibernate 的效率更快

JPA 有更好的移植性，通用性
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_110-什么是-spring-cloud"><a href="#_110-什么是-spring-cloud" class="header-anchor">#</a> 110.什么是 Spring Cloud？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>   Spring Cloud是一个微服务框架，相比Dubbo等RPC框架, Spring Cloud提供的全套的分布式系统解决方案。 

   Spring Cloud对微服务基础框架Netflix的多个开源组件进行了封装，同时又实现了和云端平台以及和Spring Boot开发框架的集成。 

   Spring Cloud为微服务架构开发涉及的配置管理，服务治理，熔断机制，智能路由，微代理，控制总线，一次性token，全局一致性锁，leader选举，分布式session，集群状态管理等操作提供了一种简单的开发方式。

   Spring Cloud 为开发者提供了快速构建分布式系统的工具，开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_111-spring-cloud-断路器的作用是什么"><a href="#_111-spring-cloud-断路器的作用是什么" class="header-anchor">#</a> 111.Spring Cloud 断路器的作用是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_112-spring-cloud-的核心组件有哪些"><a href="#_112-spring-cloud-的核心组件有哪些" class="header-anchor">#</a> 112.Spring Cloud 的核心组件有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>服务发现——Netflix Eureka

客服端负载均衡——Netflix Ribbon

断路器——Netflix Hystrix

服务网关——Netflix Zuul

分布式配置——Spring Cloud Config
 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h1 id="hibernate"><a href="#hibernate" class="header-anchor">#</a> Hibernate</h1> <h2 id="_113-为什么要使用-hibernate"><a href="#_113-为什么要使用-hibernate" class="header-anchor">#</a> 113.为什么要使用 Hibernate？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。
2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作
3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。
4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_114-什么是-orm-框架"><a href="#_114-什么是-orm-框架" class="header-anchor">#</a> 114.什么是 ORM 框架？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>对象关系映射
目前数据库是关系型数据库 ORM 主要是把数据库中的关系数据映射称为程序中的对象
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_115-hibernate-中如何在控制台查看打印的-sql-语句"><a href="#_115-hibernate-中如何在控制台查看打印的-sql-语句" class="header-anchor">#</a> 115.Hibernate 中如何在控制台查看打印的 SQL 语句？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> ![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_116-hibernate-有几种查询方式"><a href="#_116-hibernate-有几种查询方式" class="header-anchor">#</a> 116.Hibernate 有几种查询方式？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> HIbernate主要常用有三种查询方式HQL、QBC、SQL：

1).HQL（Hibernate Query Language）：hibernate数据查询语言；

2).QBC（Query By Criteria)：规则查询

3).SQL：原生的SQL语句（较为复杂的情况下使用）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_117-hibernate-实体类可以被定义为-final-吗"><a href="#_117-hibernate-实体类可以被定义为-final-吗" class="header-anchor">#</a> 117.Hibernate 实体类可以被定义为 final 吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Hibernate会使用代理模式在延迟关联的情况下提高性能，如果你把实体类定义成final类之后，因为 Java不允许对final类进行扩展，所以Hibernate就无法再使用代理了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_118-在-hibernate-中使用-integer-和-int-做映射有什么区别"><a href="#_118-在-hibernate-中使用-integer-和-int-做映射有什么区别" class="header-anchor">#</a> 118.在 Hibernate 中使用 Integer 和 int 做映射有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、返回数据库字段值是null的话，int类型会报错。int是基本数据类型，其声明的是变量，而null则是对象。所以hibernate实体建议用integer；

2、通过jdbc将实体存储到数据库的操作通过sql语句，基本数据类型可以直接存储，对象需要序列化存储。

3、在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。

4、如何序列化
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_119-hibernate-是如何工作的"><a href="#_119-hibernate-是如何工作的" class="header-anchor">#</a> 119.Hibernate 是如何工作的？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1.配置好hibernate的配置文件和与类对应的配置文件后，启动服务器
 2.服务器通过实例化Configeration对象，读取hibernate.cfg.xml文件的配置内容，并根据相关的需求建好表或者和表建立好映射关系
 3.通过实例化的Configeration对象就可以建立sessionFactory实例，进一步，通过sessionFactory实例可以创建[session对象](https://www.baidu.com/s?wd=session对象&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)
 4.得到session之后，便可以对数据库进行增删改查操作了，除了比较复杂的全文搜索外，简单的操作都可以通过hibernate封装好的session内置方法来实现
 5.此外，还可以通过事物管理，表的关联来实现较为复杂的[数据库设计](https://www.baidu.com/s?wd=数据库设计&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_120-get-和-load-的区别"><a href="#_120-get-和-load-的区别" class="header-anchor">#</a> 120.get()和 load()的区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、 查询的时机不一样 
​       get方法任何时刻都是立即加载，只要调用get方法，就马上发起数据库查询。
​       load方法默认情况下是延迟加载，真正用到对象的非OID字段数据才发起查询。
​       load方法是可以通过配置的方式改为立即加载。
​       配置的方式
   由于load方法是hibernate的方法所以只有XML的方式：
​    &lt;classname=&quot;Customer&quot; table=&quot;cst_customer&quot;lazy=&quot;false&quot;&gt; 
2、返回的结果不一样
​       get方法永远返回查询的实体类对象
​       load方法返回的是代理对象
   立即加载：是不管用不用马上查询。
   延迟加载：是等到真正用的时候才发起查询。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="_121-说一下-hibernate-的缓存机制"><a href="#_121-说一下-hibernate-的缓存机制" class="header-anchor">#</a> 121.说一下 Hibernate 的缓存机制？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Hibernate中的缓存分一级缓存和二级缓存。

一级缓存就是  Session 级别的缓存，在事务范围内有效是,内置的不能被卸载。二级缓存是 SesionFactory级别的缓存，从应用启动到应用结束有效。是可选的，默认没有二级缓存，需要手动开启。保存数据库后，缓存在内存中保存一份，如果更新了数据库就要同步更新。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_122-hibernate-对象有哪些状态"><a href="#_122-hibernate-对象有哪些状态" class="header-anchor">#</a> 122.Hibernate 对象有哪些状态？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1，Transient 瞬时 ：对象刚new出来，还没设id，设了其他值。

2，Persistent 持久：调用了save()、saveOrUpdate()，就变成Persistent，有id

3，Detached  脱管 ： 当session  close()完之后，变成Detached。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_123-在-hibernate-中-getcurrentsession-和-opensession-的区别是什么"><a href="#_123-在-hibernate-中-getcurrentsession-和-opensession-的区别是什么" class="header-anchor">#</a> 123.在 Hibernate 中 getCurrentSession 和 openSession 的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> getCurrentSession () 使用当前的session
 openSession()     重新建立一个新的session

 在一个应用程序中，如果DAO 层使用Spring 的hibernate 模板，通过Spring 来控制session 的生命周期，则首选getCurrentSession ()。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_124-hibernate-实体类必须要有无参构造函数吗-为什么"><a href="#_124-hibernate-实体类必须要有无参构造函数吗-为什么" class="header-anchor">#</a> 124.Hibernate 实体类必须要有无参构造函数吗？为什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>有些时候对象是由HIbernate创建的，如延迟加载时，hibernate在创建这个对象时会调用无参的构造方法。另外在web部分很多对象是由web容器创建的，容器或框架在创建对象时都是调用无参的构造方法。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h1 id="mybatis"><a href="#mybatis" class="header-anchor">#</a> Mybatis</h1> <h2 id="_125-mybatis-中-和-的区别是什么"><a href="#_125-mybatis-中-和-的区别是什么" class="header-anchor">#</a> 125.Mybatis 中 #{}和 ${}的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1. 将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号。如：order by #user_id#，如果传入的值是111,那么解析成sql时的值为order by &quot;111&quot;, 如果传入的值是id，则解析成的sql为order by &quot;id&quot;.　
 2.将传入的数据直接显示生成在sql中。如：order by $user_id$，如果传入的值是111,那么解析成sql时的值为order by user_id, 如果传入的值是id，则解析成的sql为order by id.
 3.方式能够很大程度防止sql注入。
 4.方式无法防止Sql注入。
 5.方式一般用于传入数据库对象，例如传入表名.
 6.一般能用#的就别用$.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="_126-mybatis-有几种分页方式"><a href="#_126-mybatis-有几种分页方式" class="header-anchor">#</a> 126.Mybatis 有几种分页方式？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 数组分页;sql分页;拦截器分页;RowBounds分页
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_127-rowbounds-是一次性查询全部结果吗-为什么"><a href="#_127-rowbounds-是一次性查询全部结果吗-为什么" class="header-anchor">#</a> 127.RowBounds 是一次性查询全部结果吗？为什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>是一次性得查询全部结果;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_128-mybatis-逻辑分页和物理分页的区别是什么"><a href="#_128-mybatis-逻辑分页和物理分页的区别是什么" class="header-anchor">#</a> 128.Mybatis 逻辑分页和物理分页的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、物理分页：
      物理分页就是[数据库](http://lib.csdn.net/base/14)本身提供了分页方式，如[MySQL](http://lib.csdn.net/base/14)的limit，好处是效率高，不好的地方就是不同数据库有不同的搞法。
2、逻辑分页：
      逻辑分页利用游标分页，好处是所有数据库都统一，坏处就是效率低。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_129-mybatis-是否支持延迟加载-延迟加载的原理是什么"><a href="#_129-mybatis-是否支持延迟加载-延迟加载的原理是什么" class="header-anchor">#</a> 129.Mybatis 是否支持延迟加载？延迟加载的原理是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>在mybatis 中默认没有使用延迟加载; ![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

3)在mybatis中,延迟加载也是使用动态代理完成的,但是在mybatis中,被代理的对象不是one方,而是many方本身.所以,默认情况下一旦我访问了这个延迟加载对象任何一个属性,都会触发这个延迟加载对象的加载(默认情况下e.getName();也会吃法dept的查询),这不是我们想要的结果,我们想要的是在需要dept的时候,才去查询dept对象.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_130-说一下-mybatis-的一级缓存和二级缓存"><a href="#_130-说一下-mybatis-的一级缓存和二级缓存" class="header-anchor">#</a> 130.说一下 Mybatis 的一级缓存和二级缓存？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>①、一级缓存是SqlSession级别的缓存。在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。

②、二级缓存是mapper级别的缓存，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_131-mybatis-和-hibernate-的区别有哪些"><a href="#_131-mybatis-和-hibernate-的区别有哪些" class="header-anchor">#</a> 131.Mybatis 和 Hibernate 的区别有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。      

2、Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。         

3、Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_132-mybatis-有哪些执行器-executor"><a href="#_132-mybatis-有哪些执行器-executor" class="header-anchor">#</a> 132.Mybatis 有哪些执行器（Executor）？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>SimpleExecutor、ReuseExecutor、BatchExecutor。

SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。

ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。

BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是
addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_133-mybatis-分页插件的实现原理是什么"><a href="#_133-mybatis-分页插件的实现原理是什么" class="header-anchor">#</a> 133.Mybatis 分页插件的实现原理是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_134-mybatis-如何编写一个自定义插件"><a href="#_134-mybatis-如何编写一个自定义插件" class="header-anchor">#</a> 134.Mybatis 如何编写一个自定义插件？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.编写Interceptor的实现类

2. 使用@Intercepts注解完成插件签名 说明插件的拦截四大对象之一的哪一个对象的哪一个方法

3. 将写好的插件注册到全局配置文件中

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h1 id="rabbitmq"><a href="#rabbitmq" class="header-anchor">#</a> RabbitMQ</h1> <h2 id="_135-rabbitmq-的使用场景有哪些"><a href="#_135-rabbitmq-的使用场景有哪些" class="header-anchor">#</a> 135.RabbitMQ 的使用场景有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 场景1：单发送单接收场景2：单发送多接收场景3：Publish/Subscribe场景4：Routing (按路线发送接收) 场景5：Topics (按topic发送接收)

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_136-rabbitmq-有哪些重要的角色"><a href="#_136-rabbitmq-有哪些重要的角色" class="header-anchor">#</a> 136.RabbitMQ 有哪些重要的角色？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>RabbitMQ的用户角色分类：

none、management、policymaker、monitoring、administrator
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_137-rabbitmq-有哪些重要的组件"><a href="#_137-rabbitmq-有哪些重要的组件" class="header-anchor">#</a> 137.RabbitMQ 有哪些重要的组件？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>路由,交换机,队列
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_138-rabbitmq-中-vhost-的作用是什么"><a href="#_138-rabbitmq-中-vhost-的作用是什么" class="header-anchor">#</a> 138.RabbitMQ 中 VHost 的作用是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Vhost在本质上是一个mini版的RabbitMq服务器,拥有自己的队列,绑定,交换机,在那个实例间提供逻辑上分离,允许你为不同应用程序安全保密地运行数据;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_139-rabbitmq-的消息是怎么发送的"><a href="#_139-rabbitmq-的消息是怎么发送的" class="header-anchor">#</a> 139.RabbitMQ 的消息是怎么发送的？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>RabbitMQ一般有工作模式,发布定位模式,路由模式,Header模式等,一般的步骤都是创建一个连接工厂,设置RabbitMq相关信息,创建一个新的链接,然后创建一个通道,声明一个队列,再将消息存储到队列中,最后关闭通道和连接
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_140-rabbitmq-怎么保证消息的不被重复消费"><a href="#_140-rabbitmq-怎么保证消息的不被重复消费" class="header-anchor">#</a> 140.RabbitMQ 怎么保证消息的不被重复消费？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>采用第三方存储,来做消费记录,以redis为例,给消息分配一个全局id,只要消费过该消息,将&lt;id,message&gt;以K-V形式写入redis,那消费者开始消费前,先去redis中查询有没有消费记录即可.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_141-rabbitmq-怎么避免消息丢失"><a href="#_141-rabbitmq-怎么避免消息丢失" class="header-anchor">#</a> 141.RabbitMQ 怎么避免消息丢失？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>有四种方式: 消息持久化(将消息永久的存储在硬盘上面,但是交换机,队列和消息必须设置持久化,以及发送模式必须设置成deliveryModel=2),ACK确认机制(使用Message acknowledgment机制),设置集群镜像模式,消息补偿机制(最推荐)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_142-要保证消息持久化成功的条件有哪些"><a href="#_142-要保证消息持久化成功的条件有哪些" class="header-anchor">#</a> 142.要保证消息持久化成功的条件有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>exchange设置持久化,queue设置持久化然后message持久化,还可以采用Confirm机制采用消息确认机制(事务+Confirm)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_143-rabbitmq-持久化有什么缺点"><a href="#_143-rabbitmq-持久化有什么缺点" class="header-anchor">#</a> 143.RabbitMQ 持久化有什么缺点？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>读写性能变低
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_144-rabbitmq-有几种广播类型"><a href="#_144-rabbitmq-有几种广播类型" class="header-anchor">#</a> 144.RabbitMQ 有几种广播类型？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>fanout广播模式;direct广播模式,能选择性的发送接收消息,在终端运行并输入参数;Topic细致的消息过滤广播模式
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_145-rabbitmq-怎么实现延迟消息队列"><a href="#_145-rabbitmq-怎么实现延迟消息队列" class="header-anchor">#</a> 145.RabbitMQ 怎么实现延迟消息队列？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>设置TTL产生死信,有两种方式Per-Message TTL和Queue TTL

在RabbitMq3.5.7及以上的版本提供了一个插件来实现延迟队列功能
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_146-rabbitmq-集群有什么用"><a href="#_146-rabbitmq-集群有什么用" class="header-anchor">#</a> 146.RabbitMQ 集群有什么用？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>集群的每个节点会保存交换器,队列,绑定等数据,而且向消费者可以通过连接任何节点来定位到需要的队列获取数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_147-rabbitmq-节点的类型有哪些"><a href="#_147-rabbitmq-节点的类型有哪些" class="header-anchor">#</a> 147.RabbitMQ 节点的类型有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>有两种类型,一种是磁盘节点,这种就是配置信息和元信息存储在磁盘上,另外一种就是内存节点,内存节点的性能是大大超越磁盘节点的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_148-rabbitmq-集群搭建需要注意哪些问题"><a href="#_148-rabbitmq-集群搭建需要注意哪些问题" class="header-anchor">#</a> 148.RabbitMQ 集群搭建需要注意哪些问题？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>在磁盘节点上有同名节点,需要删除同名节点

在注意每个节点Cookie同步,而且RabbitMq的集群是依赖于erlang的集群来工作的,必须先构建起erlang的集群环境
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_149-rabbitmq-每个节点是其他节点的完整拷贝吗-为什么"><a href="#_149-rabbitmq-每个节点是其他节点的完整拷贝吗-为什么" class="header-anchor">#</a> 149.RabbitMQ 每个节点是其他节点的完整拷贝吗？为什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>不是,因为默认情况下,队列的完整信息不会在集群下所有的节点保存,而是只存在于一个节点中
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_150-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况"><a href="#_150-rabbitmq-集群中唯一一个磁盘节点崩溃了会发生什么情况" class="header-anchor">#</a> 150.RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>不能创建队列,不能创建交换器,不能创建绑定,不能添加用户,不能更改权限,不能添加和删除集群节点
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_151-rabbitmq-对集群节点停止顺序有要求吗"><a href="#_151-rabbitmq-对集群节点停止顺序有要求吗" class="header-anchor">#</a> 151.RabbitMQ 对集群节点停止顺序有要求吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>需要先关闭内存节点,然后关闭磁盘节点
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h1 id="zookeeper"><a href="#zookeeper" class="header-anchor">#</a> ZooKeeper</h1> <h2 id="_157-zookeeper-是什么"><a href="#_157-zookeeper-是什么" class="header-anchor">#</a> 157.ZooKeeper 是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>ZooKeeper是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务。

分布式应用程序可以基于ZooKeeper实现数据发布与订阅、负载均衡、命名服务、分布式协调与通知、集群管理、Leader选举、分布式锁、分布式队列等功能
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_158-zookeeper-都有哪些功能"><a href="#_158-zookeeper-都有哪些功能" class="header-anchor">#</a> 158.ZooKeeper 都有哪些功能？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>高性能

高可用

严格顺序访问
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_159-zookeeper-有几种部署模式"><a href="#_159-zookeeper-有几种部署模式" class="header-anchor">#</a> 159.ZooKeeper 有几种部署模式？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>单机,伪集群,集群三种部署模式
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_160-zookeeper-怎么保证主从节点的状态同步"><a href="#_160-zookeeper-怎么保证主从节点的状态同步" class="header-anchor">#</a> 160.ZooKeeper 怎么保证主从节点的状态同步？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>ZK选举
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_161-集群中为什么要有主节点"><a href="#_161-集群中为什么要有主节点" class="header-anchor">#</a> 161.集群中为什么要有主节点？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_162-集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗"><a href="#_162-集群中有-3-台服务器-其中一个节点宕机-这个时候-zookeeper-还可以使用吗" class="header-anchor">#</a> 162.集群中有 3 台服务器，其中一个节点宕机，这个时候 ZooKeeper 还可以使用吗？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>可以
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_163-说一下-zookeeper-的通知机制"><a href="#_163-说一下-zookeeper-的通知机制" class="header-anchor">#</a> 163.说一下 ZooKeeper 的通知机制？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.客户端向服务端注册Watcher

2.服务端事件发生触发Watcher;

3.客户端回调Watch得到触发事件情况(客户端一直监听)

2.1.一次性触发

2.2.事件封装

2.3.event异步发送

2.4.先注册再触发
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h1 id="mysql"><a href="#mysql" class="header-anchor">#</a> MySQL</h1> <h2 id="_164-数据库的三范式是什么"><a href="#_164-数据库的三范式是什么" class="header-anchor">#</a> 164.数据库的三范式是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>第一范式：当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要

求，否则，将有很多基本操作在这样的关系模式中实现不了。

第二范式：如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。

第三范式：设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_165-一张自增表删除了最后2条数据-重启mysql数据库-又插入了一条数据-此时id是几"><a href="#_165-一张自增表删除了最后2条数据-重启mysql数据库-又插入了一条数据-此时id是几" class="header-anchor">#</a> 165.一张自增表删除了最后2条数据，重启MySQL数据库，又插入了一条数据，此时ID是几？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 8
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_166-如何获取当前数据库版本"><a href="#_166-如何获取当前数据库版本" class="header-anchor">#</a> 166.如何获取当前数据库版本？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、通过mysql的-V参数查询版本信息 mysql -V 2、登录mysql时可以查询版本信息 mysql -u用户名 -p用户密码 3、数据库状态查询版本信息 status; 4、通过mysql数据库函数查询版本信息 select version(); 5、通过version环境变量查询版本信息
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_167-说一下-acid-是什么"><a href="#_167-说一下-acid-是什么" class="header-anchor">#</a> 167.说一下 ACID 是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Atomicity原子性

Consistency一致性

Isolation隔离性

Durability耐久性
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_168-char-和-varchar-的区别是什么"><a href="#_168-char-和-varchar-的区别是什么" class="header-anchor">#</a> 168.Char 和 VarChar 的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 1．CHAR的长度是固定的，而VARCHAR2的长度是可以变化的， 比如，存储字符串“abc&quot;，对于CHAR (10)，表示你存储的字符将占10个字节(包括7个空字符)，而同样的VARCHAR2 (10)则只占用3个字节的长度，10只是最大值，当你存储的字符小于10时，按实际长度存储。
 2．CHAR的效率比VARCHAR2的效率稍高。
 3．目前VARCHAR是VARCHAR2的同义词。工业标准的VARCHAR类型可以存储[空字符串](https://www.baidu.com/s?wd=空字符串&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)，但是oracle不这样做，尽管它保留以后这样做的权利。Oracle自己开发了一个数据类型VARCHAR2，这个类型不是一个标准的VARCHAR，它将在数据库中varchar列可以存储[空字符串](https://www.baidu.com/s?wd=空字符串&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)的特性改为存储NULL值。如果你想有[向后兼容](https://www.baidu.com/s?wd=向后兼容&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)的能力，Oracle建议使用VARCHAR2而不是VARCHAR
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_169-float-和-double-的区别是什么"><a href="#_169-float-和-double-的区别是什么" class="header-anchor">#</a> 169.Float 和 Double 的区别是什么？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> float：占4个字节
 double： 占8个字节 double 和 float 的区别是double精度高，有效数字16位，float精度7位。但double消耗内存是float的两倍，double的运算速度比float慢得多,在不确定的情况下还是尽量用double以保持正确性.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_170-mysql-的内连接、左连接、右连接有什么区别"><a href="#_170-mysql-的内连接、左连接、右连接有什么区别" class="header-anchor">#</a> 170.MySQL 的内连接、左连接、右连接有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>    1.内连接,显示两个表中有联系的所有数据;

　　2.左链接,以左表为参照,显示所有数据;

　　3.右链接,以右表为参照显示数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_171-mysql索引是怎么实现的"><a href="#_171-mysql索引是怎么实现的" class="header-anchor">#</a> 171.MySQL索引是怎么实现的？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>索引是一种高效获取数据的存储结构，例：hash、 二叉、 红黑;

1、MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址；
   MyISAM主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复；

2、InnoDB的数据文件本身就是索引文件，叶节点包含了完整的数据记录，这种索引叫做聚集索引。
 因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键。
   InnoDB的辅助索引data域存储相应记录主键的值而不是地址；
   辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录；

3、页分裂问题

![https://images2018.cnblogs.com/blog/1396730/201807/1396730-20180711114710708-57905108.png](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image020.jpg)

如果主键是单调递增的，每条新记录会顺序插入到页，当页被插满后，继续插入到新的页；

如果写入是乱序的，InnoDB不得不频繁地做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。

如果频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_172-怎么验证-mysql的索引是否满足需求"><a href="#_172-怎么验证-mysql的索引是否满足需求" class="header-anchor">#</a> 172.怎么验证 MySQL的索引是否满足需求？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.比较频繁的作为查询的字段

2.唯一性太差的字段不适合加索引，要找唯一性比较好的

3.更新太频繁的字段不适合做索引

4.不会出现在where中的 不应该建立索引
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_173-说一下数据库的事务隔离"><a href="#_173-说一下数据库的事务隔离" class="header-anchor">#</a> 173.说一下数据库的事务隔离？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>多个并发的事务同时访问一个数据库时，一个事务不应该被另一个事务所干扰，每个并发的事务间要相互进行隔离
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_174-说一下-mysql常用的引擎"><a href="#_174-说一下-mysql常用的引擎" class="header-anchor">#</a> 174.说一下 MySQL常用的引擎？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Innodb和MyIASM。MyIASM引擎，它是MySql的默认引擎，但不提供事务的支持
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_175-说一下-mysql的行锁和表锁"><a href="#_175-说一下-mysql的行锁和表锁" class="header-anchor">#</a> 175.说一下 MySQL的行锁和表锁？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>表级锁：每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；

行级锁：每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_176-说一下乐观锁和悲观锁"><a href="#_176-说一下乐观锁和悲观锁" class="header-anchor">#</a> 176.说一下乐观锁和悲观锁？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_177-mysql问题排查都有哪些手段"><a href="#_177-mysql问题排查都有哪些手段" class="header-anchor">#</a> 177.MySQL问题排查都有哪些手段？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>事物级别

输出数据当前状态

查询数据库连接信息

查询事务信息

查询数据库锁等待信息

手动杀掉某个进程

数据库客户端连接ip统计

查询数据库指定连接的当前执行sql

查询锁等待的前后事物和客户端调用的简单sql
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h2 id="_178-如何做-mysql的性能优化"><a href="#_178-如何做-mysql的性能优化" class="header-anchor">#</a> 178.如何做 MySQL的性能优化？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.为查询缓存优化你的查询

2.EXPLAIN你的SELECT查询 

3.当只要一行数据时使用LIMIT1

4.为搜索字段建索引

5.在Join表的时候使用相当类型的例，并将其索引

6.千万不要ORDER BY RAND() 

7.避免 SELECT *

8.永远为每张表设置一个ID

9.使用ENUM而不是VARCHAR

10.从PROCEDURE ANALYSE()

11.尽可能的使用NOT NULL

12. Prepared Statements

13.无缓冲的查询 

14.把IP地址存成UNSIGNED INT 

15.固定长度的表会更快

16.垂直分割 

17.拆分大的DELETE或INSERT语句 

18.越小的列会越快 

19.选择正确的存储引擎 

20.使用一个对象关系映射器

21.小心“永久链接”
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><h1 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h1> <h2 id="_179-redis-是什么-都有哪些使用场景"><a href="#_179-redis-是什么-都有哪些使用场景" class="header-anchor">#</a> 179.Redis 是什么？都有哪些使用场景？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>redis是一款高性能的NOSQL系列的非关系型数据库
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_180-redis-有哪些功能"><a href="#_180-redis-有哪些功能" class="header-anchor">#</a> 180.Redis 有哪些功能？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>   (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) 
   (2) 支持丰富数据类型，支持string，list，set，sorted set，hash 
   (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 
   (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_181-redis-和-memecache-有什么区别"><a href="#_181-redis-和-memecache-有什么区别" class="header-anchor">#</a> 181.Redis 和 MemeCache 有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>　　 1)、存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。 
 　　2)、数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。 
 　　3)、使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_182-redis-为什么是单线程的"><a href="#_182-redis-为什么是单线程的" class="header-anchor">#</a> 182.Redis 为什么是单线程的？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>redis 核心就是 如果我的数据全都在内存里，我单线程的去操作 就是效率最高的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_183-什么是缓存穿透-怎么解决"><a href="#_183-什么是缓存穿透-怎么解决" class="header-anchor">#</a> 183.什么是缓存穿透？怎么解决？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞;

处理缓存穿透的方法有很多，其实无外乎就是对数据进行过滤筛选，把真正有效的数据进行访问，无效数据直接过滤掉
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_184-redis-支持的数据类型有哪些"><a href="#_184-redis-支持的数据类型有哪些" class="header-anchor">#</a> 184.Redis 支持的数据类型有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1) 字符串类型 string

2) 哈希类型 hash

3) 列表类型 list

4) 集合类型 set

​5) 有序集合类型 sortedset
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_185-redis-支持的-java-客户端都有哪些"><a href="#_185-redis-支持的-java-客户端都有哪些" class="header-anchor">#</a> 185.Redis 支持的 Java 客户端都有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Redisson,Jedis，lettuce等等，官方推荐使用Redisson。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_186-jedis-和-redisson-有哪些区别"><a href="#_186-jedis-和-redisson-有哪些区别" class="header-anchor">#</a> 186.Jedis 和 Redisson 有哪些区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1  Redisson提供了和Spring框架的各项特性类似的，以Spring XML的命名空间的方式配置RedissonClient实例和它所支持的所有对象和服务；

2  Redisson完整的实现了Spring框架里的缓存机制；

3  Redisson在Redis的基础上实现了Java缓存标准规范；

4  Redisson为Apache Tomcat集群提供了基于Redis的非黏性会话管理功能。该功能支持Apache Tomcat的6、7和8版。

5  Redisson还提供了Spring Session会话管理器的实现
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_187-怎么保证缓存和数据库数据的一致性"><a href="#_187-怎么保证缓存和数据库数据的一致性" class="header-anchor">#</a> 187.怎么保证缓存和数据库数据的一致性？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 先删除缓存，再修改数据库，如果删除缓存成功了，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致,因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_188-redis-持久化有几种方式"><a href="#_188-redis-持久化有几种方式" class="header-anchor">#</a> 188.Redis 持久化有几种方式？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.RDB：默认方式，不需要进行配置，默认就使用这种机制

2.AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="_189-redis-怎么实现分布式锁"><a href="#_189-redis-怎么实现分布式锁" class="header-anchor">#</a> 189.Redis 怎么实现分布式锁？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image022.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_190-redis-分布式锁有什么缺陷"><a href="#_190-redis-分布式锁有什么缺陷" class="header-anchor">#</a> 190.Redis 分布式锁有什么缺陷？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>存在死锁的问题

SETNX实现分布式锁，可能会存在死锁的情况。与单机模式下的锁相比，分布式环境下不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。某个线程获取了锁之后，断开了与Redis 的连接，锁没有及时释放，竞争该锁的其他线程都会hung，产生死锁的情况。

在使用 SETNX 获得锁时，我们将键 lock.id 的值设置为锁的有效时间，线程获得锁后，其他线程还会不断的检测锁是否已超时，如果超时，等待的线程也将有机会获得锁。然而，锁超时，我们不能简单地使用 DEL 命令删除键 lock.id 以释放锁。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_191-redis-如何做内存优化"><a href="#_191-redis-如何做内存优化" class="header-anchor">#</a> 191.Redis 如何做内存优化？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>一.redisObject对象

二.缩减键值对象

三.共享对象池

四.字符串优化

五.编码优化

六.控制key的数量
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_192-redis-淘汰策略有哪些"><a href="#_192-redis-淘汰策略有哪些" class="header-anchor">#</a> 192.Redis 淘汰策略有哪些？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了

2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）

3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊

4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key（这个一般不太合适）

5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key

6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="_193-redis-常见的性能问题有哪些-该如何解决"><a href="#_193-redis-常见的性能问题有哪些-该如何解决" class="header-anchor">#</a> 193.Redis 常见的性能问题有哪些？该如何解决？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。

2.Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。

3.Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。

4.Redis主从复制的性能问题，第一次Slave向Master同步的实现是：Slave向Master发出同步请求，Master先dump出rdb文件，然后将rdb文件全量传输给slave，然后Master把缓存的命令转发给Slave，初次同步完成。第二次以及以后的同步实现是：Master将变量的快照直接实时依次发送给各个Slave。不管什么原因导致Slave和Master断开重连都会重复以上过程。Redis的主从复制是建立在内存快照的持久化基础上，只要有Slave就一定会有内存快照发生。虽然Redis宣称主从复制无阻塞，但由于磁盘io的限制，如果Master快照文件比较大，那么dump会耗费比较长的时间，这个过程中Master可能无法响应请求，也就是说服务会中断，对于关键服务，这个后果也是很可怕的。

1.Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化。

2.如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。

3.为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。

4.尽量避免在压力较大的主库上增加从库

5.为了Master的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;--Slave1&lt;--Slave2&lt;--Slave3.......，这样的结构也方便解决单点故障问题，实现Slave对Master的替换，也即，如果Master挂了，可以立马启用Slave1做Master，其他不变。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h1 id="jvm"><a href="#jvm" class="header-anchor">#</a> JVM</h1> <h2 id="_194-说一下-jvm-的主要组成部分-及其作用"><a href="#_194-说一下-jvm-的主要组成部分-及其作用" class="header-anchor">#</a> 194.说一下 JVM 的主要组成部分？及其作用？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>JVM内存区域分为五个部分，分别是堆，方法区，虚拟机栈，本地方法栈，程序计数器

堆。 堆是Java对象的存储区域，任何用new字段分配的Java对象实例和数组，都被分配在堆上，Java堆可使用-Xms -Xmx进行内存控制，值得一提的是从JDK1.7版本之后，运行时常量池从方法区移到了堆上。

方法区。它用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据，方法区在JDK1.7版本及以前被称为永久代，从JDK1.8永久代被移除。

虚拟机栈。虚拟机栈中执行每个方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。

本地方法栈。与虚拟机栈发挥的作用相似，相比于虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务，执行每个本地方法的时候，都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。

程序计数器。指示Java虚拟机下一条需要执行的字节码指令。 

以上五个区域是Java虚拟机内存划分情况，其中方法区和堆被JVM中多个线程共享，比如类的静态常量就被存放在方法区，供类对象之间共享，虚拟机栈，本地方法栈，pc寄存器是每个线程独立拥有的，不会与其他线程共享。 

所以Java在通过new创建一个类对象实例的时候，一方面会在虚拟机栈中创建一个该对象的引用，另一方面会在堆上创建类对象的实例，然后将对象引用指向该对象的实例。对象引用存放在每一个方法对应的栈帧中。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h2 id="_195-说一下-jvm-运行时数据区"><a href="#_195-说一下-jvm-运行时数据区" class="header-anchor">#</a> 195.说一下 JVM 运行时数据区？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image024.jpg)
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_196-说一下堆栈的区别"><a href="#_196-说一下堆栈的区别" class="header-anchor">#</a> 196.说一下堆栈的区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code> 程序的局部变量存在于（栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中
 这样说比较准确,所谓的栈其实是由寄存器ebp和esp指向的一片内存空间(ebp指向栈底,esp指向栈顶),原则上是由高地址向低地址生长的一片空间,会保存一些临时的数据,比如一个函数中的临时变量以及返回地址,数据的出入是先进后出,后进先出.
 全局变量实际上是存在一个(一般来说正常的编译器)可读可写的内存空间,这个空间是在你写程序编译好的空间地址(由编译器决定),是固定的.
 堆是由[操作系统](https://www.baidu.com/s?wd=操作系统&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao)管理的一片空间,事先是没有在进程空间里分配的(比如你在没有分配堆的时候就访问堆空间会报一个内存访问错误),一般是由程序动态的分配出来,一旦分配了以后,一般需要程序去释放自己的堆空间
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="_197-队列和栈是什么-有什么区别"><a href="#_197-队列和栈是什么-有什么区别" class="header-anchor">#</a> 197.队列和栈是什么？有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1：队列和栈是两种不同的数据结构。它们有以下区别：

（1）操作的名称不同。队列的插入称为入队，队列的删除称为出队。栈的插入称为进栈，栈的删除称为出栈。

（2）可操作的方式不同。队列是在队尾入队，队头出队，即两边都可操作。而栈的进栈和出栈都是在栈顶进行的，无法对栈底直接进行操作。

（3）操作的方法不同。队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_198-什么是双亲委派模型"><a href="#_198-什么是双亲委派模型" class="header-anchor">#</a> 198.什么是双亲委派模型？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>双亲委派模型要求除顶层启动类加载器外其余类加载器都应该有自己的父类加载器；类加载器之间通过复用关系来复用父加载器的代码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_199-说一下类加载的执行过程"><a href="#_199-说一下类加载的执行过程" class="header-anchor">#</a> 199.说一下类加载的执行过程？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>实例通过使用 new()关键字创建 或者 使用class.forName()反射，但它有可能导致ClassNotFoundException。

类的静态方法被调用

类的静态域被赋值从

静态域被访问，而且它不是常量

在顶层类中执行assert语句

clone方式：clone只是复制拷贝(深拷贝需要new，浅拷贝不需要，原来的对象的改变不反应在拷贝对象上)

反序列化：readObject是从文件中还原对象

 类的加载顺序:

① 父类静态块--子类静态块--父类初始化块--父类构造方法--子类初始化块--子类构造方法

② 静态块---main()---初始化构造块-----构造方法（简化版）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="_200-怎么判断对象是否可以被回收"><a href="#_200-怎么判断对象是否可以被回收" class="header-anchor">#</a> 200.怎么判断对象是否可以被回收？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>JVM判断一个对象是否存活用的是可达性分析而不是引用计数法

引用计数法

引用计数法思路是这样的，给对象添加一个引用计数器，有地方引用时，计数器就加1；当引用失效时就减1；当计数为0的时候就判定对象需要被回收

引用计数法有一个难以解决的问题就是相互循环引用问题。可达性分析算法

这个算法的基本思路是通过一些列称为“GC Roots”的对象作为起始点，从这些点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象需要被回收.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="_201-java-中都有哪些引用类型"><a href="#_201-java-中都有哪些引用类型" class="header-anchor">#</a> 201.Java 中都有哪些引用类型？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>引用数据类型分3种：类，接口，数组；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_202-说一下-jvm-有哪些垃圾回收算法"><a href="#_202-说一下-jvm-有哪些垃圾回收算法" class="header-anchor">#</a> 202.说一下 JVM 有哪些垃圾回收算法？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>引用计数器算法, 可达性分析算法
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_203-说一下-jvm-有哪些垃圾回收器"><a href="#_203-说一下-jvm-有哪些垃圾回收器" class="header-anchor">#</a> 203.说一下 JVM 有哪些垃圾回收器？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、Serial(年轻代）2、ParNew(年轻代）3、Paralle Scavenge(年轻代）4、Serial Old(年老代）5、Parallel Old(年老代）6、CMS(Concurrent Mark Sweep年老代）7、G1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="_204-详细介绍一下-cms-垃圾回收器"><a href="#_204-详细介绍一下-cms-垃圾回收器" class="header-anchor">#</a> 204.详细介绍一下 CMS 垃圾回收器？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>垃圾回收器从线程运行情况分类有三种

串行回收，Serial回收器，单线程回收，全程stw；

并行回收，名称以Parallel开头的回收器，多线程回收，全程stw；

并发回收，cms与G1，多线程分阶段回收，只有某阶段会stw；

CMS垃圾回收特点

cms只会回收老年代和永久带（1.8开始为元数据区，需要设置CMSClassUnloadingEnabled），不会收集年轻带；

cms是一种预处理垃圾回收器，它不能等到old内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以cms垃圾回收器开始执行回收操作，有一个触发阈值，默认是老年代或永久带达到92%；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="_205-新生代垃圾回收器和老生代垃圾回收器都有哪些-有什么区别"><a href="#_205-新生代垃圾回收器和老生代垃圾回收器都有哪些-有什么区别" class="header-anchor">#</a> 205.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>新生代的GC：

新生代通常存活时间较短，因此基于复制算法来进行回收，所谓复制算法就是扫描出存活的对象，并复制到一块新的完全未使用的空间中.

对应于新生代：就是在Eden和其中一个Survivor，复制到另一个之间Survivor空间中，然后清理掉原来就是在Eden和其中一个Survivor中的对象。

新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在新生代区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。

当连续分配对象时，对象会逐渐从eden到 survivor，最后到老年代。

用javavisualVM来查看，能明显观察到新生代满了后，会把对象转移到旧生代，然后清空继续装载，当旧生代也满了后，就会报outofmemory的异常。

在执行机制上JVM提供了串行GC（SerialGC）、并行回收GC（ParallelScavenge）和并行GC（ParNew）

1）串行GC

在整个扫描和复制过程采用单线程的方式来进行，适用于单CPU、新生代空间较小及对暂停时间要求不是非常高的应用上，是client级别默认的GC方式，

可以通过-XX:+UseSerialGC来强制指定

2）并行回收GC

在整个扫描和复制过程采用多线程的方式来进行，适用于多CPU、对暂停时间要求较短的应用上，是server级别默认采用的GC方式，

可用-XX:+UseParallelGC来强制指定，用-XX:ParallelGCThreads=4来指定线程数

3）并行GC

与旧生代的并发GC配合使用。


老年代的GC：

旧生代与新生代不同，对象存活的时间比较长，比较稳定，因此采用标记（Mark）算法来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗。在执行机制上JVM提供了串行 GC（SerialMSC）、并行GC（parallelMSC）和并发GC（CMS），具体算法细节还有待进一步深入研究。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h2 id="_206-说一下-jvm-调优的工具"><a href="#_206-说一下-jvm-调优的工具" class="header-anchor">#</a> 206.说一下 JVM 调优的工具？</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Java安装目录的bin文件加下有一些工具可以用来监控JVM性能，如jconsole、jvisualvm、jmap、jps、jstack、jhat、jstat等

207.常用的 JVM 调优的参数都有哪些？

一、Trace跟踪参数（跟踪GC、类、变量的内存变化情况）

打开GC跟踪日志（每次执行GC的信息都能打印，获得执行时间，空间大小）：

-verbose:gc 或 -XX:+printGC 或 -XX:+printGCDetails

类加载监控：（监控类加载的顺序）

-XX:+TraceClassLoading

二、堆的分频参数

-Xmx10M 指定最大堆，JVM最多能够使用的堆空间 （超过该空间引发OOM）

-Xms5M 指定最小堆，JVM至少会有的堆空间（尽可能维持在最小堆）

-Xmn 11M（new） 设置新生代大小

总结：

1.根据实际情况调整新生代和幸存代的大小

2.官方推荐：新生代占堆空间3/8

3.幸存代占新生代1/10

4.OOM时，dump出堆到文件，方便排查


三、栈的分配参数

-Xss 每个线程都有独立的栈空间（几百k，比较小）

需要大量线程时，需要尽可能减小栈空间

栈空间太小-----StackOverFlow栈溢出（一般递归时产生大量局部变量导致）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div></div> <footer class="page-edit" style="display:none;"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">11/11/2020, 9:50:46 AM</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div><div class="container" data-v-0178ff65><canvas id="live2d" width="280" height="250" class="live2d-right" data-v-0178ff65></canvas></div><!----></div></div>
    <script src="/assets/js/app.df9b6469.js" defer></script><script src="/assets/js/3.cc36008b.js" defer></script><script src="/assets/js/1.fecf3d02.js" defer></script><script src="/assets/js/17.cc47030b.js" defer></script>
  </body>
</html>
